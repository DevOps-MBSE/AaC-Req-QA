"""The AaC Req QA plugin implementation module."""

# NOTE: It is safe to edit this file.
# This file is only initially generated by aac gen-plugin, and it won't be overwritten if the file already exists.

# There may be some unused imports depending on the definition of the plugin, be sure to remove unused imports.
from typing import Any

import os

from aac.context.definition import Definition
from aac.context.language_context import LanguageContext
from aac.context.source_location import SourceLocation
from aac.execute.aac_execution_result import (
    ExecutionResult,
    ExecutionStatus,
    ExecutionMessage,
    MessageLevel,
)
from aac.in_out.files.aac_file import AaCFile

plugin_name = "Req QA"

PROMPT_TEMPLATE = """
# IDENTITY and PURPOSE

You are an objectively minded and centrist-oriented analyzer of system engineering artifacts and requirements.

You specialize in analyzing and rating the quality of requirement statements in the input provided and providing both evidence in support of those ratings, as well as counter-arguments and counter-evidence that are relevant to those ratings.  You know that a good requirement should have the following characteristics:

- Unambiguous: The requirement should be simple, direct, and precise with no room for interpretation.
- Testable (verifiable): The requirement should be testable, and it should be possible to verify that the system meets the requirement.  Preferable the requirement should be verifiable by automated acceptance test, automated analysis, or demonstration rather than inspection.  If inspection is the only rational means of verification it will have a lower rating.
- Clear: The requiremet should be concise, terse, simple, and precise.
- Correct:  The requirement should not have any false or invalid assertions.
- Understandable:  The requirement should be easily understood by all stakeholders.
- Feasible: The requirement should be realistic and achievable.
- Independent:  The requirement should stand-alone and not be dependent on other requirements.
- Atomic: The requirement should be a single, discrete, and indivisible statement.
- Necessary: The requirement should be necessary to the system and not be redundant or superfluous.
- Implementation-free: The requirement should not specify how the system will be implemented.  It should only specify what the system should do, not how it should do it.

The purpose is to provide a concise and balanced view of the requirement provided in a given piece of input so that one can assess the engineering quality of the statement.

Take a step back and think step by step about how to achieve the best possible output given the goals above.

# Steps

- Deeply analyze the requirement being made in the input.
- Separate the characteristics of a good requirement to provide a wholistic evaluation in your mind.

# OUTPUT INSTRUCTIONS

- Provide a summary of the requirement in less than 30 words in a section called REQUIREMENT SUMMARY:.

- In a section called QUALITY ASSESSMENT:, perform the following steps for quality characteristic:

1. List the quality characteristic being evaluated in less than 15 words in a subsection called EVALUATION:.
2. Provide solid, verifiable evidence that this requirement is compliant to the quality characteristic. Provide rationale for each, and DO NOT make any of those up. They must be 100% real and externally verifiable. Put each of these in a subsection called QUALITY COMPLIANCE ASSESSMENT:.

3. Provide solid, verifiable evidence that this requirement is non-compliant to the quality characteristic. Provide rationale for each, and DO NOT make any of those up. They must be 100% real and externally verifiable. Put each of these in a subsection called QUALITY NON-COMPLIANCE ASSESSMENT:.

4. Provide a REQUIREMENT QUALITY score in a section called REQUIREMENT RATING:, that has the following tiers:
   A (Excellent)
   B (High)
   C (Medium)
   D (Low)
   F (Terrible)

# INPUT:

The rotary management system shall prevent the user from entering a negative value for the number of rotations. 

"""


def shall_statement_quality(
    instance: Any, definition: Definition, defining_schema: Any
) -> ExecutionResult:
    """
     Business logic for the Shall statement quality constraint.

     Args:
         instance (Any): The instance to be checked.
         definition (Definition): The definition of the instance.
         defining_schema (Any): The schema that defines the instance.


    Returns:
         The results of the execution of the Shall statement quality command.
    """

    # Only evaluate req root keys.
    if definition.get_root_key() != "req":
        return ExecutionResult(
            plugin_name,
            "Shall statement quality",
            ExecutionStatus.SUCCESS ,
            [
                ExecutionMessage(
                    "No req to evaluate",
                    MessageLevel.SUCCESS,
                    definition.source,
                    None,
                )
            ],
        )

    # Check to see if the env variables OPEN_AI_URL, OPEN_AI_MODEL, and OPEN_AI_KEY exist and have a value
    # If they do not exist or have no value, return an error message
    open_ai_url = os.getenv("OPEN_AI_URL")
    open_ai_model = os.getenv("OPEN_AI_MODEL")
    open_ai_key = os.getenv("OPEN_AI_KEY")

    if ((open_ai_url is None or open_ai_url == "") or
        (open_ai_model is None or open_ai_model == "") or
        (open_ai_key is None or open_ai_key == "")):
        return ExecutionResult(
            plugin_name,
            "Shall statement quality",
            ExecutionStatus.CONSTRAINT_WARNING ,
            [
                ExecutionMessage(
                    "The OPEN_AI_URL, OPEN_AI_MODEL, or OPEN_AI_KEY environment variable is not set. Unable to evaluate the Shall statement quality constraint.",
                    MessageLevel.WARNING,
                    definition.source,
                    None,
                )
            ],
        )

    # TODO: rewrite the code below to implement your constraint logic
    # you can get the source and location from the definition for messages
    status = ExecutionStatus.GENERAL_FAILURE
    messages: list[ExecutionMessage] = []
    error_msg = ExecutionMessage(
        "The Shall statement quality constraint for the Req QA plugin has not been implemented yet.",
        MessageLevel.ERROR,
        definition.source,
        None,
    )
    messages.append(error_msg)

    return ExecutionResult(plugin_name, "Shall statement quality", status, messages)
